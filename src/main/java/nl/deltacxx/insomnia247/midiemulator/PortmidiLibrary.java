package nl.deltacxx.insomnia247.midiemulator;
import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.Structure;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.List;
/**
 * JNA Wrapper for library <b>portmidi</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface PortmidiLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = "portmidi";
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(PortmidiLibrary.JNA_LIBRARY_NAME);
	public static final PortmidiLibrary INSTANCE = (PortmidiLibrary)Native.loadLibrary(PortmidiLibrary.JNA_LIBRARY_NAME, PortmidiLibrary.class);
	/** enum values */
	public static interface PmError {
		/** <i>native declaration : line 108</i> */
		public static final int pmNoError = 0;
		/**
		 * < A "no error" return that also indicates no data avail.<br>
		 * <i>native declaration : line 109</i>
		 */
		public static final int pmNoData = 0;
		/**
		 * < A "no error" return that also indicates data available<br>
		 * <i>native declaration : line 110</i>
		 */
		public static final int pmGotData = 1;
		/** <i>native declaration : line 111</i> */
		public static final int pmHostError = -10000;
		/**
		 * out of range or <br>
		 * output device when input is requested or <br>
		 * input device when output is requested or<br>
		 * device is already opened<br>
		 * <i>native declaration : line 112</i>
		 */
		public static final int pmInvalidDeviceId = -9999;
		/** <i>native declaration : line 117</i> */
		public static final int pmInsufficientMemory = -9998;
		/** <i>native declaration : line 118</i> */
		public static final int pmBufferTooSmall = -9997;
		/** <i>native declaration : line 119</i> */
		public static final int pmBufferOverflow = -9996;
		/**
		 * PortMidiStream parameter is NULL or<br>
		 * stream is not opened or<br>
		 * stream is output when input is required or<br>
		 * stream is input when output is required<br>
		 * <i>native declaration : line 120</i>
		 */
		public static final int pmBadPtr = -9995;
		/**
		 * illegal midi data, e.g. missing EOX<br>
		 * <i>native declaration : line 124</i>
		 */
		public static final int pmBadData = -9994;
		/** <i>native declaration : line 125</i> */
		public static final int pmInternalError = -9993;
		/**
		 * buffer is already as large as it can be<br>
		 * <i>native declaration : line 126</i>
		 */
		public static final int pmBufferMaxSize = -9992;
	};
	public static final int FALSE = (int)0;
	public static final int TRUE = (int)1;
	public static final int PM_DEFAULT_SYSEX_BUFFER_SIZE = (int)1024;
	public static final int HDRLENGTH = (int)50;
	public static final int PM_HOST_ERROR_MSG_LEN = (int)256;
	public static final int pmNoDevice = (int)-1;
	public static final int PM_FILT_ACTIVE = (int)(1 << 0x0E);
	public static final int PM_FILT_SYSEX = (int)(1 << 0x00);
	public static final int PM_FILT_CLOCK = (int)(1 << 0x08);
	public static final int PM_FILT_PLAY = (int)((1 << 0x0A) | (1 << 0x0C) | (1 << 0x0B));
	public static final int PM_FILT_TICK = (int)(1 << 0x09);
	public static final int PM_FILT_FD = (int)(1 << 0x0D);
	public static final int PM_FILT_UNDEFINED = (int)(1 << 0x0D);
	public static final int PM_FILT_RESET = (int)(1 << 0x0F);
	public static final int PM_FILT_REALTIME = (int)((1 << 0x0E) | (1 << 0x00) | (1 << 0x08) | ((1 << 0x0A) | (1 << 0x0C) | (1 << 0x0B)) | (1 << 0x0D) | (1 << 0x0F) | (1 << 0x09));
	public static final int PM_FILT_NOTE = (int)((1 << 0x19) | (1 << 0x18));
	public static final int PM_FILT_CHANNEL_AFTERTOUCH = (int)(1 << 0x1D);
	public static final int PM_FILT_POLY_AFTERTOUCH = (int)(1 << 0x1A);
	public static final int PM_FILT_AFTERTOUCH = (int)((1 << 0x1D) | (1 << 0x1A));
	public static final int PM_FILT_PROGRAM = (int)(1 << 0x1C);
	public static final int PM_FILT_CONTROL = (int)(1 << 0x1B);
	public static final int PM_FILT_PITCHBEND = (int)(1 << 0x1E);
	public static final int PM_FILT_MTC = (int)(1 << 0x01);
	public static final int PM_FILT_SONG_POSITION = (int)(1 << 0x02);
	public static final int PM_FILT_SONG_SELECT = (int)(1 << 0x03);
	public static final int PM_FILT_TUNE = (int)(1 << 0x06);
	public static final int PM_FILT_SYSTEMCOMMON = (int)((1 << 0x01) | (1 << 0x02) | (1 << 0x03) | (1 << 0x06));
	public static class PmDeviceInfo extends Structure {
		/** < this internal structure version */
		public int structVersion;
		/**
		 * < underlying MIDI API, e.g. MMSystem or DirectX<br>
		 * C type : const char*
		 */
		public Pointer interf;
		/**
		 * < device name, e.g. USB MidiSport 1x1<br>
		 * C type : const char*
		 */
		public Pointer name;
		/** < true iff input is available */
		public int input;
		/** < true iff output is available */
		public int output;
		/** < used by generic PortMidi code to do error checking on arguments */
		public int opened;
		public PmDeviceInfo() {
			super();
		}
		protected List<String> getFieldOrder() {
			return Arrays.asList("structVersion", "interf", "name", "input", "output", "opened");
		}
		/**
		 * @param structVersion < this internal structure version<br>
		 * @param interf < underlying MIDI API, e.g. MMSystem or DirectX<br>
		 * C type : const char*<br>
		 * @param name < device name, e.g. USB MidiSport 1x1<br>
		 * C type : const char*<br>
		 * @param input < true iff input is available<br>
		 * @param output < true iff output is available<br>
		 * @param opened < used by generic PortMidi code to do error checking on arguments
		 */
		public PmDeviceInfo(int structVersion, Pointer interf, Pointer name, int input, int output, int opened) {
			super();
			this.structVersion = structVersion;
			this.interf = interf;
			this.name = name;
			this.input = input;
			this.output = output;
			this.opened = opened;
		}
		public PmDeviceInfo(Pointer peer) {
			super(peer);
		}
		public static class ByReference extends PmDeviceInfo implements Structure.ByReference {
			
		};
		public static class ByValue extends PmDeviceInfo implements Structure.ByValue {
			
		};
	};
	public static class PmEvent extends Structure {
		/** C type : PmMessage */
		public int message;
		/** C type : PmTimestamp */
		public int timestamp;
		public PmEvent() {
			super();
		}
		protected List<String> getFieldOrder() {
			return Arrays.asList("message", "timestamp");
		}
		/**
		 * @param message C type : PmMessage<br>
		 * @param timestamp C type : PmTimestamp
		 */
		public PmEvent(int message, int timestamp) {
			super();
			this.message = message;
			this.timestamp = timestamp;
		}
		public PmEvent(Pointer peer) {
			super(peer);
		}
		public static class ByReference extends PmEvent implements Structure.ByReference {
			
		};
		public static class ByValue extends PmEvent implements Structure.ByValue {
			
		};
	};
	public interface PmTimeProcPtr extends Callback {
		int apply(Pointer time_info);
	};
	/**
	 * Pm_Initialize() is the library initialisation function - call this before<br>
	 * using the library.<br>
	 * Original signature : <code>PmError Pm_Initialize()</code><br>
	 * <i>native declaration : line 134</i>
	 */
	int Pm_Initialize();
	/**
	 * Pm_Terminate() is the library termination function - call this after<br>
	 * using the library.<br>
	 * Original signature : <code>PmError Pm_Terminate()</code><br>
	 * <i>native declaration : line 140</i>
	 */
	int Pm_Terminate();
	/**
	 * Test whether stream has a pending host error. Normally, the client finds<br>
	 * out about errors through returned error codes, but some errors can occur<br>
	 * asynchronously where the client does not<br>
	 * explicitly call a function, and therefore cannot receive an error code.<br>
	 * The client can test for a pending error using Pm_HasHostError(). If true,<br>
	 * the error can be accessed and cleared by calling Pm_GetErrorText(). <br>
	 * Errors are also cleared by calling other functions that can return<br>
	 * errors, e.g. Pm_OpenInput(), Pm_OpenOutput(), Pm_Read(), Pm_Write(). The<br>
	 * client does not need to call Pm_HasHostError(). Any pending error will be<br>
	 * reported the next time the client performs an explicit function call on <br>
	 * the stream, e.g. an input or output operation. Until the error is cleared,<br>
	 * no new error codes will be obtained, even for a different stream.<br>
	 * Original signature : <code>int Pm_HasHostError(PortMidiStream*)</code><br>
	 * <i>native declaration : line 161</i>
	 */
	int Pm_HasHostError(PortmidiLibrary.PortMidiStream stream);
	/**
	 * Translate portmidi error number into human readable message.<br>
	 * These strings are constants (set at compile time) so client has <br>
	 * no need to allocate storage<br>
	 * Original signature : <code>char* Pm_GetErrorText(PmError)</code><br>
	 * <i>native declaration : line 168</i>
	 */
	Pointer Pm_GetErrorText(int errnum);
	/**
	 * Translate portmidi host error into human readable message.<br>
	 * These strings are computed at run time, so client has to allocate storage.<br>
	 * After this routine executes, the host error is cleared.<br>
	 * Original signature : <code>void Pm_GetHostErrorText(char*, unsigned int)</code><br>
	 * <i>native declaration : line 174</i><br>
	 * @deprecated use the safer methods {@link #Pm_GetHostErrorText(java.nio.ByteBuffer, int)} and {@link #Pm_GetHostErrorText(com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	void Pm_GetHostErrorText(Pointer msg, int len);
	/**
	 * Translate portmidi host error into human readable message.<br>
	 * These strings are computed at run time, so client has to allocate storage.<br>
	 * After this routine executes, the host error is cleared.<br>
	 * Original signature : <code>void Pm_GetHostErrorText(char*, unsigned int)</code><br>
	 * <i>native declaration : line 174</i>
	 */
	void Pm_GetHostErrorText(ByteBuffer msg, int len);
	/**
	 * Get devices count, ids range from 0 to Pm_CountDevices()-1.<br>
	 * Original signature : <code>int Pm_CountDevices()</code><br>
	 * <i>native declaration : line 198</i>
	 */
	int Pm_CountDevices();
	/**
	 * Pm_GetDefaultInputDeviceID(), Pm_GetDefaultOutputDeviceID()<br>
	 * Return the default device ID or pmNoDevice if there are no devices.<br>
	 * The result (but not pmNoDevice) can be passed to Pm_OpenMidi().<br>
	 * The default device can be specified using a small application<br>
	 * named pmdefaults that is part of the PortMidi distribution. This<br>
	 * program in turn uses the Java Preferences object created by<br>
	 * java.util.prefs.Preferences.userRoot().node("/PortMidi"); the<br>
	 * preference is set by calling <br>
	 * prefs.put("PM_RECOMMENDED_OUTPUT_DEVICE", prefName);<br>
	 * or  prefs.put("PM_RECOMMENDED_INPUT_DEVICE", prefName);<br>
	 * In the statements above, prefName is a string describing the<br>
	 * MIDI device in the form "interf, name" where interf identifies<br>
	 * the underlying software system or API used by PortMdi to access<br>
	 * devices and name is the name of the device. These correspond to <br>
	 * the interf and name fields of a PmDeviceInfo. (Currently supported<br>
	 * interfaces are "MMSystem" for Win32, "ALSA" for Linux, and <br>
	 * "CoreMIDI" for OS X, so in fact, there is no choice of interface.)<br>
	 * In "interf, name", the strings are actually substrings of <br>
	 * the full interface and name strings. For example, the preference <br>
	 * "Core, Sport" will match a device with interface "CoreMIDI"<br>
	 * and name "In USB MidiSport 1x1". It will also match "CoreMIDI"<br>
	 * and "In USB MidiSport 2x2". The devices are enumerated in device<br>
	 * ID order, so the lowest device ID that matches the pattern becomes<br>
	 * the default device. Finally, if the comma-space (", ") separator<br>
	 * between interface and name parts of the preference is not found,<br>
	 * the entire preference string is interpreted as a name, and the<br>
	 * interface part is the empty string, which matches anything.<br>
	 * On the MAC, preferences are stored in <br>
	 * /Users/$NAME/Library/Preferences/com.apple.java.util.prefs.plist<br>
	 * which is a binary file. In addition to the pmdefaults program,<br>
	 * there are utilities that can read and edit this preference file.<br>
	 * On the PC, <br>
	 * On Linux,<br>
	 * Original signature : <code>PmDeviceID Pm_GetDefaultInputDeviceID()</code><br>
	 * <i>native declaration : line 241</i>
	 */
	int Pm_GetDefaultInputDeviceID();
	/**
	 * see PmDeviceID Pm_GetDefaultInputDeviceID()<br>
	 * Original signature : <code>PmDeviceID Pm_GetDefaultOutputDeviceID()</code><br>
	 * <i>native declaration : line 243</i>
	 */
	int Pm_GetDefaultOutputDeviceID();
	/**
	 * Pm_GetDeviceInfo() returns a pointer to a PmDeviceInfo structure<br>
	 * referring to the device specified by id.<br>
	 * If id is out of range the function returns NULL.<br>
	 * The returned structure is owned by the PortMidi implementation and must<br>
	 * not be manipulated or freed. The pointer is guaranteed to be valid<br>
	 * between calls to Pm_Initialize() and Pm_Terminate().<br>
	 * Original signature : <code>PmDeviceInfo* Pm_GetDeviceInfo(PmDeviceID)</code><br>
	 * <i>native declaration : line 267</i>
	 */
	PortmidiLibrary.PmDeviceInfo Pm_GetDeviceInfo(int id);
	/**
	 * Pm_OpenInput() and Pm_OpenOutput() open devices.<br>
	 * stream is the address of a PortMidiStream pointer which will receive<br>
	 * a pointer to the newly opened stream.<br>
	 * inputDevice is the id of the device used for input (see PmDeviceID above).<br>
	 * inputDriverInfo is a pointer to an optional driver specific data structure<br>
	 * containing additional information for device setup or handle processing.<br>
	 * inputDriverInfo is never required for correct operation. If not used<br>
	 * inputDriverInfo should be NULL.<br>
	 * outputDevice is the id of the device used for output (see PmDeviceID above.)<br>
	 * outputDriverInfo is a pointer to an optional driver specific data structure<br>
	 * containing additional information for device setup or handle processing.<br>
	 * outputDriverInfo is never required for correct operation. If not used<br>
	 * outputDriverInfo should be NULL.<br>
	 * For input, the buffersize specifies the number of input events to be <br>
	 * buffered waiting to be read using Pm_Read(). For output, buffersize <br>
	 * specifies the number of output events to be buffered waiting for output. <br>
	 * (In some cases -- see below -- PortMidi does not buffer output at all<br>
	 * and merely passes data to a lower-level API, in which case buffersize<br>
	 * is ignored.)<br>
	 * latency is the delay in milliseconds applied to timestamps to determine <br>
	 * when the output should actually occur. (If latency is < 0, 0 is assumed.) <br>
	 * If latency is zero, timestamps are ignored and all output is delivered<br>
	 * immediately. If latency is greater than zero, output is delayed until the<br>
	 * message timestamp plus the latency. (NOTE: the time is measured relative <br>
	 * to the time source indicated by time_proc. Timestamps are absolute,<br>
	 * not relative delays or offsets.) In some cases, PortMidi can obtain<br>
	 * better timing than your application by passing timestamps along to the<br>
	 * device driver or hardware. Latency may also help you to synchronize midi<br>
	 * data to audio data by matching midi latency to the audio buffer latency.<br>
	 * time_proc is a pointer to a procedure that returns time in milliseconds. It<br>
	 * may be NULL, in which case a default millisecond timebase (PortTime) is <br>
	 * used. If the application wants to use PortTime, it should start the timer<br>
	 * (call Pt_Start) before calling Pm_OpenInput or Pm_OpenOutput. If the<br>
	 * application tries to start the timer *after* Pm_OpenInput or Pm_OpenOutput,<br>
	 * it may get a ptAlreadyStarted error from Pt_Start, and the application's<br>
	 * preferred time resolution and callback function will be ignored.<br>
	 * time_proc result values are appended to incoming MIDI data, and time_proc<br>
	 * times are used to schedule outgoing MIDI data (when latency is non-zero).<br>
	 * time_info is a pointer passed to time_proc.<br>
	 * Example: If I provide a timestamp of 5000, latency is 1, and time_proc<br>
	 * returns 4990, then the desired output time will be when time_proc returns<br>
	 * timestamp+latency = 5001. This will be 5001-4990 = 11ms from now.<br>
	 * return value:<br>
	 * Upon success Pm_Open() returns PmNoError and places a pointer to a<br>
	 * valid PortMidiStream in the stream argument.<br>
	 * If a call to Pm_Open() fails a nonzero error code is returned (see<br>
	 * PMError above) and the value of port is invalid.<br>
	 * Any stream that is successfully opened should eventually be closed<br>
	 * by calling Pm_Close().<br>
	 * Original signature : <code>PmError Pm_OpenInput(PortMidiStream**, PmDeviceID, void*, int32_t, PmTimeProcPtr, void*)</code><br>
	 * <i>native declaration : line 333</i>
	 */
	int Pm_OpenInput(PointerByReference stream, int inputDevice, Pointer inputDriverInfo, int bufferSize, PortmidiLibrary.PmTimeProcPtr time_proc, Pointer time_info);
	/**
	 * Original signature : <code>PmError Pm_OpenOutput(PortMidiStream**, PmDeviceID, void*, int32_t, PmTimeProcPtr, void*, int32_t)</code><br>
	 * <i>native declaration : line 340</i>
	 */
	int Pm_OpenOutput(PointerByReference stream, int outputDevice, Pointer outputDriverInfo, int bufferSize, PortmidiLibrary.PmTimeProcPtr time_proc, Pointer time_info, int latency);
	/**
	 * All System Common messages (mtc, song position, song select, tune request)<br>
	 * Original signature : <code>PmError Pm_SetFilter(PortMidiStream*, int32_t)</code><br>
	 * <i>native declaration : line 414</i>
	 */
	int Pm_SetFilter(PortmidiLibrary.PortMidiStream stream, int filters);
	/**
	 * Pm_SetChannelMask() filters incoming messages based on channel.<br>
	 * The mask is a 16-bit bitfield corresponding to appropriate channels.<br>
	 * The Pm_Channel macro can assist in calling this function.<br>
	 * i.e. to set receive only input on channel 1, call with<br>
	 * Pm_SetChannelMask(Pm_Channel(1));<br>
	 * Multiple channels should be OR'd together, like<br>
	 * Pm_SetChannelMask(Pm_Channel(10) | Pm_Channel(11))<br>
	 * Note that channels are numbered 0 to 15 (not 1 to 16). Most <br>
	 * synthesizer and interfaces number channels starting at 1, but<br>
	 * PortMidi numbers channels starting at 0.<br>
	 * All channels are allowed by default<br>
	 * Original signature : <code>PmError Pm_SetChannelMask(PortMidiStream*, int)</code><br>
	 * <i>native declaration : line 432</i>
	 */
	int Pm_SetChannelMask(PortmidiLibrary.PortMidiStream stream, int mask);
	/**
	 * Pm_Abort() terminates outgoing messages immediately<br>
	 * The caller should immediately close the output port;<br>
	 * this call may result in transmission of a partial midi message.<br>
	 * There is no abort for Midi input because the user can simply<br>
	 * ignore messages in the buffer and close an input device at<br>
	 * any time.<br>
	 * Original signature : <code>PmError Pm_Abort(PortMidiStream*)</code><br>
	 * <i>native declaration : line 442</i>
	 */
	int Pm_Abort(PortmidiLibrary.PortMidiStream stream);
	/**
	 * Pm_Close() closes a midi stream, flushing any pending buffers.<br>
	 * (PortMidi attempts to close open streams when the application <br>
	 * exits -- this is particularly difficult under Windows.)<br>
	 * Original signature : <code>PmError Pm_Close(PortMidiStream*)</code><br>
	 * <i>native declaration : line 449</i>
	 */
	int Pm_Close(PortmidiLibrary.PortMidiStream stream);
	/**
	 * Pm_Synchronize() instructs PortMidi to (re)synchronize to the<br>
	 * time_proc passed when the stream was opened. Typically, this<br>
	 * is used when the stream must be opened before the time_proc<br>
	 * reference is actually advancing. In this case, message timing<br>
	 * may be erratic, but since timestamps of zero mean <br>
	 * "send immediately," initialization messages with zero timestamps<br>
	 * can be written without a functioning time reference and without<br>
	 * problems. Before the first MIDI message with a non-zero<br>
	 * timestamp is written to the stream, the time reference must<br>
	 * begin to advance (for example, if the time_proc computes time<br>
	 * based on audio samples, time might begin to advance when an <br>
	 * audio stream becomes active). After time_proc return values<br>
	 * become valid, and BEFORE writing the first non-zero timestamped <br>
	 * MIDI message, call Pm_Synchronize() so that PortMidi can observe<br>
	 * the difference between the current time_proc value and its<br>
	 * MIDI stream time. <br>
	 * In the more normal case where time_proc <br>
	 * values advance continuously, there is no need to call <br>
	 * Pm_Synchronize. PortMidi will always synchronize at the <br>
	 * first output message and periodically thereafter.<br>
	 * Original signature : <code>PmError Pm_Synchronize(PortMidiStream*)</code><br>
	 * <i>native declaration : line 474</i>
	 */
	int Pm_Synchronize(PortmidiLibrary.PortMidiStream stream);
	/**
	 * Pm_Read() retrieves midi data into a buffer, and returns the number<br>
	 * of events read. Result is a non-negative number unless an error occurs, <br>
	 * in which case a PmError value will be returned.<br>
	 * Buffer Overflow<br>
	 * The problem: if an input overflow occurs, data will be lost, ultimately <br>
	 * because there is no flow control all the way back to the data source. <br>
	 * When data is lost, the receiver should be notified and some sort of <br>
	 * graceful recovery should take place, e.g. you shouldn't resume receiving <br>
	 * in the middle of a long sysex message.<br>
	 * With a lock-free fifo, which is pretty much what we're stuck with to <br>
	 * enable portability to the Mac, it's tricky for the producer and consumer <br>
	 * to synchronously reset the buffer and resume normal operation.<br>
	 * Solution: the buffer managed by PortMidi will be flushed when an overflow<br>
	 * occurs. The consumer (Pm_Read()) gets an error message (pmBufferOverflow)<br>
	 * and ordinary processing resumes as soon as a new message arrives. The<br>
	 * remainder of a partial sysex message is not considered to be a "new<br>
	 * message" and will be flushed as well.<br>
	 * Original signature : <code>int Pm_Read(PortMidiStream*, PmEvent*, int32_t)</code><br>
	 * <i>native declaration : line 593</i>
	 */
	int Pm_Read(PortmidiLibrary.PortMidiStream stream, PortmidiLibrary.PmEvent buffer, int length);
	/**
	 * Pm_Poll() tests whether input is available, <br>
	 * returning TRUE, FALSE, or an error value.<br>
	 * Original signature : <code>PmError Pm_Poll(PortMidiStream*)</code><br>
	 * <i>native declaration : line 599</i>
	 */
	int Pm_Poll(PortmidiLibrary.PortMidiStream stream);
	/**
	 * Pm_Write() writes midi data from a buffer. This may contain:<br>
	 * - short messages <br>
	 * or <br>
	 * - sysex messages that are converted into a sequence of PmEvent<br>
	 * structures, e.g. sending data from a file or forwarding them<br>
	 * from midi input.<br>
	 * Use Pm_WriteSysEx() to write a sysex message stored as a contiguous <br>
	 * array of bytes.<br>
	 * Sysex data may contain embedded real-time messages.<br>
	 * Original signature : <code>PmError Pm_Write(PortMidiStream*, PmEvent*, int32_t)</code><br>
	 * <i>native declaration : line 614</i>
	 */
	int Pm_Write(PortmidiLibrary.PortMidiStream stream, PortmidiLibrary.PmEvent buffer, int length);
	/**
	 * Pm_WriteShort() writes a timestamped non-system-exclusive midi message.<br>
	 * Messages are delivered in order as received, and timestamps must be <br>
	 * non-decreasing. (But timestamps are ignored if the stream was opened<br>
	 * with latency = 0.)<br>
	 * Original signature : <code>PmError Pm_WriteShort(PortMidiStream*, PmTimestamp, int32_t)</code><br>
	 * <i>native declaration : line 622</i>
	 */
	int Pm_WriteShort(PortmidiLibrary.PortMidiStream stream, int when, int msg);
	/**
	 * Pm_WriteSysEx() writes a timestamped system-exclusive midi message.<br>
	 * Original signature : <code>PmError Pm_WriteSysEx(PortMidiStream*, PmTimestamp, unsigned char*)</code><br>
	 * <i>native declaration : line 627</i><br>
	 * @deprecated use the safer methods {@link #Pm_WriteSysEx(portmidi.PortmidiLibrary.PortMidiStream, int, java.nio.ByteBuffer)} and {@link #Pm_WriteSysEx(portmidi.PortmidiLibrary.PortMidiStream, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int Pm_WriteSysEx(PortmidiLibrary.PortMidiStream stream, int when, Pointer msg);
	/**
	 * Pm_WriteSysEx() writes a timestamped system-exclusive midi message.<br>
	 * Original signature : <code>PmError Pm_WriteSysEx(PortMidiStream*, PmTimestamp, unsigned char*)</code><br>
	 * <i>native declaration : line 627</i>
	 */
	int Pm_WriteSysEx(PortmidiLibrary.PortMidiStream stream, int when, ByteBuffer msg);
	public static class PortMidiStream extends PointerType {
		public PortMidiStream(Pointer address) {
			super(address);
		}
		public PortMidiStream() {
			super();
		}
	};
}
